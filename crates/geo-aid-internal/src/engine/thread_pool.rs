use std::sync::mpsc;
use std::thread;

/// A pool of threads prepared to handle a specific kind of task.
pub struct ThreadPool<T: Send + 'static> {
    task_senders: Vec<mpsc::Sender<Message<T>>>,
    result_receiver: mpsc::Receiver<Worker<T>>,
    idle_workers: Vec<Worker<T>>,
}

impl<T: Send + 'static> ThreadPool<T> {
    /// Creates a new [`ThreadPool`] based on the worker count.
    /// Each task gets its mutable context created with `context_fn`
    /// that can later be accessed and mutated in `execute_fn`.
    #[must_use]
    pub fn new<
        C: Send + 'static,
        F: Fn(Option<C>) -> T + Clone + Send + 'static,
        E: Fn(&mut T) + Clone + Send + 'static,
    >(
        worker_count: usize,
        context_fn: F,
        context_args: impl IntoIterator<Item = C>,
        execute_fn: E,
    ) -> Self {
        let (result_sender, result_receiver) = mpsc::channel();
        let mut context_args = context_args.into_iter();

        let task_senders = (0..worker_count)
            .map(|id| {
                let (task_sender, task_receiver) = mpsc::channel();
                let ctx = context_fn.clone();
                let exec = execute_fn.clone();
                let result_sender = result_sender.clone();
                let arg = context_args.next();

                thread::spawn(move || {
                    let context = ctx(arg);
                    result_sender
                        .send(Worker {
                            worker_id: id,
                            payload: context,
                        })
                        .unwrap();

                    while let Ok(msg) = task_receiver.recv() {
                        match msg {
                            Message::Terminate => break,
                            Message::Task(mut context) => {
                                exec(&mut context);
                                result_sender
                                    .send(Worker {
                                        worker_id: id,
                                        payload: context,
                                    })
                                    .unwrap();
                            }
                        }
                    }
                });

                task_sender
            })
            .collect();

        let workers = (0..worker_count)
            .map(|_| result_receiver.recv().unwrap())
            .collect();

        Self {
            task_senders,
            result_receiver,
            idle_workers: workers,
        }
    }

    /// Executes tasks generated by the `tasks` function.
    /// If the function returns `false`, the process
    /// will be stopped, remaining tasks will be completed
    /// and the function will return.
    pub fn execute(
        &mut self,
        mut task_fn: impl FnMut(&mut T) -> bool,
        mut result_callback: impl FnMut(&T),
    ) {
        let mut tasks_sent = 0;

        while let Some(mut worker) = self.idle_workers.pop() {
            if !task_fn(&mut worker.payload) {
                self.idle_workers.push(worker);
                break;
            }

            tasks_sent += 1;
            self.task_senders[worker.worker_id]
                .send(Message::Task(worker.payload))
                .unwrap();
        }

        loop {
            let mut worker = self.result_receiver.recv().unwrap();

            result_callback(&worker.payload);
            if !task_fn(&mut worker.payload) {
                self.idle_workers.push(worker);

                // There's no re-sending of a task, so we decrease tasks_sent
                tasks_sent -= 1;

                break;
            }

            // If there's no breaking, task does not get re-sent and there's no
            // change in tasks_sent

            self.task_senders[worker.worker_id]
                .send(Message::Task(worker.payload))
                .unwrap();
        }

        // All tasks are sent, we can just await every other task.
        for _ in 0..tasks_sent {
            let mut worker = self.result_receiver.recv().unwrap();
            result_callback(&mut worker.payload);
            self.idle_workers.push(worker);
        }
    }
}

impl<T: Send + 'static> Drop for ThreadPool<T> {
    fn drop(&mut self) {
        for sender in &self.task_senders {
            sender.send(Message::Terminate).unwrap();
        }
    }
}

enum Message<T> {
    Task(T),
    Terminate,
}

struct Worker<R> {
    worker_id: usize,
    payload: R,
}
